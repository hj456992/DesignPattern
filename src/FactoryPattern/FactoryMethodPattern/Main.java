package FactoryPattern.FactoryMethodPattern;

/**
 * 工厂方法模式：
 * 定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让一个类的实例化延迟到其子类。
 *
 * 设计思路：
 * 既然工厂类与分支耦合，那么我就对它下手，根据依赖倒转原则，我们把工厂类抽象出一个接口，
 * 这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，
 * 这样，一个简单工厂模式的工厂类，变成了一个工厂抽象接口和多个具体生成对象的工厂，
 * 于是我们要增加‘求M数的N次方’的功能时，就不需要更改原有的工厂类了，只需要增加此功能的运算类和相应的工厂类就可以了。
 *
 * 局限性：
 * 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，
 * 也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。
 * 你想要加功能，本来是改工厂类的，而现在是修改客户端。
 *
 * 和简单工厂优缺点对比：
 * 集中封装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户程序与产品对象的耦合。
 * 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。
 * 但缺点是由于每加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。
 *
 *
 * 场景：
 * 同简单工厂模式，生成四则运算的计算功能，并可在不改变原有类的情况下拓展运算功能
 * Created by houjue on 2018/11/11.
 */
public class Main {

    public static void main(String[] args) {
        // 创建一个工厂
        CalFactory factory = new AddFactory();
        // 实现加法运算
        Operation operation = factory.createOperation();
        operation.setNumberA(20);
        operation.setNumberB(30);
        System.out.println(operation.getResult());
    }
}
